.header
	position: relative
	height: 95vh
	background-image: linear-gradient(to right bottom,rgba(126, 213, 111, 0.8),rgba(40, 180, 131, 0.8)),url(../img/hero.webp)
	background-size: cover
	background-position: top
	clip-path: polygon(0 0,100% 0,100% 75vh, 0 100%)
	// now if we change the viewport height it will also change dynamically
	&__logo-box
		position: absolute
		top: 40px
		left: 40px
	&__logo
		height: 35px
		// the width we'll scale accordingly. We don't even have to specify it. All we do is to specify the height, and the width will be automatically figured out by the browser. We could instead also set the width and then the height would be figured out by the browser. But we prefer to control the height of elements.
	&__text-box
		position: absolute
		top: 40%
		left: 50%
		transform: translate(-50%,-50%)
		// left: 50% - this here is clearly 50% from the left this part of the box, which is where the measure starts. So where the 50% starts counting. It's from left side, all the way to this side(where stays our text box) and it's 50%, it's half of the element, half of the header. It's 50% of the width of the parent element. And the same thing aplies to the top.
		// transform: translate(-50%,-50%) - that's because these 50% are now no longer in relation to the parent element, but of the element itself. And so if we say we want minus 50%, it will be shifted half of the width to the left side, and the same from the hight. So minus 50% says that it will be shifted 50% of the element's height to the top.
		text-align: center
	&__heading-primary
		color: #fff
		text-transform: uppercase
		backface-visibility: hidden
		// So the entire heading-primary element, because you see actually this entire element is what moves on this animation. It's a bit shaky, and it's the entire heading-primary element. This backface-visibility property determines if the back part of the element when we transform it is visible or hidden for user. So imagine we have an element and we rotate it 180 degrees.We use this fix here, like this hack in order to fix this little shaking that we see an animation.
		margin-bottom: 60px
	&__heading-primary-main
		display: block
		font-size: 60px
		font-weight: 400
		letter-spacing: 35px
		// block elements occopy the entire width that they have available. And more importantly for this,case, they create line breaks after and before them.
		animation-name: moveInLeft
		animation-duration: 1s
		animation-timing-function: ease-out
		// ease-in function, the animation will start slower, and then accelerate over time. And ease-out it's opposite,so it will start faster and it will become slower by the end.
		// This is a function which defines how the animation will proceed. So, how fast or how slow these parameters that we spacified here happen over time.
		// ------------------------------------------
		// animation-delay: 3s
		// so now before this animation starts to play, it will 	 first wait 3 seconds.
		// ------------------------------------------
		// animation-iteration-count: 3
		// The animation will simply happen three times

	&__heading-primary-sub
		display: block
		font-size: 20px
		font-weight: 700
		letter-spacing: 17.4px
		animation: moveInRight 1s ease-out /** you can put all of these together, and css will figure out what means what.**/

	@keyframes moveInLeft
		// So we start with 0% which is before the annimation actually starts.
		0% // Initial position is a lot more to the left.

			opacity: 0
			// Why translateX? Because we want it to animate in the x-direction. 
			transform: translateX(-100px)
			// The direction goes from left to right. So a positive value means it goes to the right, and negative value means it goes to the left.
			// --------------------------------------------
		80% // Intermediate position, is a bit more to the right

			transform: translateX(10px)
			// If we're specifying s positive value here,it will go to the right side.
			// --------------------------------------------
			// Then the finish is the 100%, which is when the animation finishes.
		100% // Final position is 0

			opacity: 1
			transform: translate(0)
			// Why 0? Well because, if we translate at 0, then it's gonna look exactly the way that it looks right now.

			// So that's one of the properties that we're animating here. Now for the browsers performance, it's best to only ever animate two different properties. One is opasity, which is the one that we're using here, and the other one is the transform property. That's what the browsers are optimized for these two properties. But with transform, we can do a whole lot.
			// part 8 4:00
	@keyframes moveInRight
		0%
			opacity: 0
			transform: translateX(100px)
			// If it's a plus value, it moves the element to the right. Because it goes forward in the x-direction.
		80%
			transform: translateX(-10px)
			// If it's a plus value, it moves the element to the right. Because it goes forward in the x-direction.
		100%
			opacity: 1
			transform: translateX(0)
	.btn
		&:link,&:visited
			// This here is a pseudo-class, it's the link pseudo-class.So this link here is a state of the button selector.
			text-transform: uppercase
			text-decoration: none
			padding: 15px 40px
			// it's occupying here this space on the top of this other text where it shouldn't. That's because it's right now an inline element. So this button here is right now an inline element, because it's simply text, but we should display it as an inline-block.
			display: inline-block
			// And this way the box model works on this element as if it was a normal block element. So we should always do this if we want to give some padding or some heights or width to element.
			border-radius: 100px
			// If you put 200 or 500px it will all still be the same.

			transition: all .2s
			// All the properties are enabled to be animated. 
			// And this is actually causes sometimes a lot of confusion as to why the transition property has to be on the initial state. So on the initial states, we say that there can be a transition basically on all the properties and then on the hover, so here we say, how it should look like in the hover state and in the active state and then the animation is going to happen.
		&:hover
			transform: translateY(-3px)
			// we want it to move up, so we use a negative value, because Y move from the top to the bottom, and we wont to move up, we have to go other way around and so it's negative. Go up it's negative value.
			// It's another transform on the hover as well as on the active will be animated in relation to their initial state. 
			box-shadow: 0 5px 10px rgba(0,0,0,.2)
			// And since we don't wont any shadow in the x direction, you only want it in the y direction. Now in y, which is the second one, we actually want some offset - 10px, so the shadow will be 5px down. Then the third value is the blur that we want see. Let's say 10px so we have a really high blur here, and this makes for a more blurry shadow, so it looks like we're further away. And so in the active box shadow , we're then going to reduce that the blur and that it looks like we're back closer to the page. And here now, finally, we can put a color. So an RGBA in this case because we want the color of the shadow to be transparent. So here we put it to black, complete black, and then let's just put a transparency value. So this is black, but not completely black, but only with 20% opacity, in order to make it just a very subtle shadow and not all to visible. 
		&:active
			transform: translateY(-1px)
			// Now when we clicked it, remember it looked a bit different. So it's the active state remember, when we click element then that's called the active srate. 
			// So this -1px up is in relation to the initial state to the link state, not to the hover. So it's not -1px in relation to to the hover state, but it's always here  to the initial link state. 
			// When we click, it goes down a bit.
		&-white
			background-color: #fff
			color: #777
